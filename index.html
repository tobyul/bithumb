<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Rei's ë¹—ì¸ ì‹œì„¸ - ìŠ¤ë§ˆíŠ¸ ë§¤ë§¤</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community@32/styles/ag-grid.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community@32/styles/ag-theme-alpine.css" />

  <style>
    body { background: #f5f5f5; font-family: 'Segoe UI', Arial, sans-serif; margin: 0; padding: 20px; }
    .coin-name { font-size: 12px; color: #666; }
    .coin-en-name { font-size: 11px; color: #aaa; }
    .login-container {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    .login-box {
      background: white;
      padding: 40px;
      border-radius: 15px;
      box-shadow: 0 15px 35px rgba(0,0,0,0.1);
      width: 100%;
      max-width: 400px;
      text-align: center;
    }
    .login-title {
      font-size: 28px;
      font-weight: bold;
      color: #333;
      margin-bottom: 10px;
    }
    .login-subtitle {
      color: #666;
      margin-bottom: 30px;
      font-size: 14px;
    }
    .form-group {
      margin-bottom: 20px;
      text-align: left;
    }
    .form-label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: #333;
    }
    .form-input {
      width: 100%;
      padding: 12px 15px;
      border: 2px solid #e1e5e9;
      border-radius: 8px;
      font-size: 16px;
      transition: border-color 0.3s;
      box-sizing: border-box;
    }
    .form-input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    .login-btn {
      width: 100%;
      padding: 12px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .login-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
    }
    .login-btn:active {
      transform: translateY(0);
    }
    .error-message {
      color: #dc3545;
      font-size: 14px;
      margin-top: 10px;
      padding: 10px;
      background: #f8d7da;
      border-radius: 5px;
      border: 1px solid #f5c6cb;
    }
    .main-container {
      max-width: 2400px;
      margin: 0 auto;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      min-height: 800px;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 2px solid #e9ecef;
    }
    .user-info {
      display: flex;
      align-items: center;
      gap: 15px;
    }
    .user-welcome {
      color: #333;
      font-weight: 500;
    }
    .logout-btn {
      background: #dc3545;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    .logout-btn:hover {
      background: #c82333;
    }
    h1 { text-align: center; margin-bottom: 10px; color: #333; }
    .datetime-display {
      text-align: center;
      color: #666;
      font-size: 14px;
      margin-bottom: 20px;
      background: #f8f9fa;
      padding: 8px;
      border-radius: 4px;
    }
    .control-panel {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    .refresh-btn, .filter-btn {
      background: #007bff;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 8px 16px;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .refresh-btn:hover, .filter-btn:hover { background: #0056b3; }
    .filter-btn.active { background: #28a745; }
    .filter-btn.favorites { background: #ffc107; color: #333; }
    .filter-btn.favorites:hover { background: #e0a800; }
    .filter-btn.favorites.active { background: #fd7e14; color: #fff; }
    .filter-btn.recommended { background: #dc3545; color: #fff; }
    .filter-btn.recommended:hover { background: #c82333; }
    .filter-btn.recommended.active { background: #bd2130; }
    .filter-btn.signals { background: #17a2b8; color: #fff; }
    .filter-btn.signals:hover { background: #138496; }
    .filter-btn.signals.active { background: #117a8b; }
    #myGrid { 
      height: 600px; 
      width: 100%; 
      min-height: 600px;
    }
    .loading { text-align: center; color: #666; margin: 20px 0; }
    .favorite-star {
      cursor: pointer;
      font-size: 20px;
      margin-right: 8px;
      transition: all 0.2s ease;
      user-select: none;
      display: inline-block;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      text-align: center;
      line-height: 24px;
    }
    .favorite-star.inactive {
      color: #ddd;
      text-shadow: 0 0 1px #999;
      background: transparent;
    }
    .favorite-star.active {
      color: #ffc107;
      text-shadow: 0 0 3px rgba(255, 193, 7, 0.5);
      background: rgba(255, 193, 7, 0.1);
      transform: scale(1.1);
    }
    .favorite-star:hover {
      color: #ffc107;
      text-shadow: 0 0 3px rgba(255, 193, 7, 0.8);
      transform: scale(1.2);
      background: rgba(255, 193, 7, 0.2);
    }
    .favorite-star:active {
      transform: scale(0.9);
    }
    .symbol-cell {
      display: flex;
      align-items: center;
      height: 100%;
    }
    .symbol-info {
      flex: 1;
    }
    .coin-count {
      text-align: center;
      color: #666;
      font-size: 12px;
      margin-top: 10px;
    }
    .ag-row.favorite-row {
      background-color: #fffbf0 !important;
      border-left: 3px solid #ffc107 !important;
    }
    .ag-row.favorite-row:hover {
      background-color: #fff8e1 !important;
    }
    .ag-row.recommended-row {
      background-color: #fff5f5 !important;
      border-left: 3px solid #dc3545 !important;
    }
    .ag-row.recommended-row:hover {
      background-color: #ffe6e6 !important;
    }
    .ag-row.signal-row {
      background-color: #f0f8ff !important;
      border-left: 3px solid #17a2b8 !important;
    }
    .ag-row.signal-row:hover {
      background-color: #e6f3ff !important;
    }
    .score-cell {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      font-weight: bold;
      border-radius: 4px;
      margin: 2px;
    }
    .grade-A-plus { background: #d4edda; color: #155724; }
    .grade-A { background: #d1ecf1; color: #0c5460; }
    .grade-B-plus { background: #fff3cd; color: #856404; }
    .grade-B { background: #ffeaa7; color: #6c5ce7; }
    .grade-C { background: #f8d7da; color: #721c24; }
    .grade-D { background: #f5c6cb; color: #721c24; }
    .target-price {
      color: #28a745;
      font-weight: bold;
      font-size: 13px;
    }
    .stop-loss {
      color: #dc3545;
      font-weight: bold;
      font-size: 13px;
    }
    .no-trade {
      color: #6c757d;
      font-style: italic;
      font-size: 12px;
    }
    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #333;
      color: white;
      padding: 12px 20px;
      border-radius: 4px;
      z-index: 1000;
      animation: slideIn 0.3s ease-out;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      max-width: 350px;
    }
    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    .hidden {
      display: none !important;
    }
    .stability-very-stable { color: #28a745; }
    .stability-stable { color: #17a2b8; }
    .stability-moderate { color: #ffc107; }
    .stability-volatile { color: #dc3545; }
    .stability-insufficient { color: #6c757d; }
    .trend-upward { color: #28a745; }
    .trend-downward { color: #dc3545; }
    .trend-sideways { color: #6c757d; }
    .buy-signal-strong { color: #dc3545; font-weight: bold; }
    .buy-signal-wait { color: #6c757d; }
  </style>
</head>
<body>
  <!-- ë¡œê·¸ì¸ í™”ë©´ -->
  <div id="loginScreen" class="login-container">
    <div class="login-box">
      <div class="login-title">ğŸª™ Crypto Trading</div>
      <div class="login-subtitle">ë¹—ì¸ ì‹œì„¸ ìŠ¤ë§ˆíŠ¸ ë§¤ë§¤ ë¶„ì„</div>
      <form id="loginForm">
        <div class="form-group">
          <label class="form-label" for="username">ì‚¬ìš©ìëª…</label>
          <input type="text" id="username" class="form-input" placeholder="ì‚¬ìš©ìëª…ì„ ì…ë ¥í•˜ì„¸ìš”" required>
        </div>
        <div class="form-group">
          <label class="form-label" for="password">ë¹„ë°€ë²ˆí˜¸</label>
          <input type="password" id="password" class="form-input" placeholder="ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”" required>
        </div>
        <button type="submit" class="login-btn">ë¡œê·¸ì¸</button>
        <div id="errorMessage" class="error-message hidden"></div>
      </form>
    </div>
  </div>

  <!-- ë©”ì¸ í™”ë©´ -->
  <div id="mainScreen" class="hidden">
    <div class="main-container">
      <div class="header">
        <h1>ğŸª™ Rei's ë¹—ì¸ ì•”í˜¸í™”í ìŠ¤ë§ˆíŠ¸ ë§¤ë§¤ ë¶„ì„</h1>
        <div class="user-info">
          <span class="user-welcome" id="userWelcome">í™˜ì˜í•©ë‹ˆë‹¤!</span>
          <button class="logout-btn" onclick="logout()">ë¡œê·¸ì•„ì›ƒ</button>
        </div>
      </div>
      <div id="datetime" class="datetime-display"></div>
      <div class="control-panel">
        <button class="refresh-btn" onclick="loadCryptoData()">ğŸ”„ ìƒˆë¡œê³ ì¹¨</button>
        <button class="filter-btn" id="allCoinsBtn" onclick="toggleFilter('all')">ğŸ“Š ì „ì²´ ì½”ì¸</button>
        <button class="filter-btn favorites" id="favoritesBtn" onclick="toggleFilter('favorites')">â­ ê´€ì‹¬ ì½”ì¸</button>
        <button class="filter-btn recommended" id="recommendedBtn" onclick="toggleFilter('recommended')">ğŸ¯ ì¶”ì²œ ì½”ì¸</button>
        <button class="filter-btn signals" id="signalsBtn" onclick="toggleFilter('signals')">ğŸš€ ë§¤ìˆ˜ ì‹ í˜¸</button>
        <button class="refresh-btn" onclick="clearHistory()">ğŸ—‘ï¸ íˆìŠ¤í† ë¦¬ ì´ˆê¸°í™”</button>
      </div>
      <div id="loading" class="loading" style="display: none;">ë°ì´í„° ë¡œë”© ì¤‘...</div>
      <div id="myGrid" class="ag-theme-alpine"></div>
      <div id="coinCount" class="coin-count"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/ag-grid-community@32/dist/ag-grid-community.min.js"></script>
  <script>
    // 1. ë§ˆì¼“ ì •ë³´ ì €ì¥ìš©
    let marketInfoMap = {};
    
    // 2. ì ìˆ˜ íˆìŠ¤í† ë¦¬ ê´€ë¦¬
    let scoreHistory = JSON.parse(localStorage.getItem('scoreHistory')) || {};

    // 3. ë§ˆì¼“ ì •ë³´ ë¶ˆëŸ¬ì˜¤ê¸°
    async function loadMarketInfo() {
      try {
        const res = await fetch('https://api.bithumb.com/v1/market/all');
        const json = await res.json();
        
        console.log('API ì‘ë‹µ:', json);
        
        if (Array.isArray(json)) {
          json.forEach(item => {
            if (!item.market) return;
            const symbol = item.market.split('-')[1];
            marketInfoMap[symbol] = {
              korean_name: item.korean_name,
              english_name: item.english_name
            };
          });
          console.log('ë§¤í•‘ëœ ë§ˆì¼“ ì •ë³´:', marketInfoMap);
        } else {
          console.error('ì˜ˆìƒê³¼ ë‹¤ë¥¸ API ì‘ë‹µ êµ¬ì¡°:', json);
          setDefaultMarketInfo();
        }
      } catch (e) {
        console.error('ë§ˆì¼“ ì •ë³´ ë¡œë“œ ì‹¤íŒ¨:', e);
        setDefaultMarketInfo();
      }
    }

    // 4. ê¸°ë³¸ ë§ˆì¼“ ì •ë³´ ì„¤ì • í•¨ìˆ˜
    function setDefaultMarketInfo() {
      marketInfoMap = {
        'BTC': { korean_name: 'ë¹„íŠ¸ì½”ì¸', english_name: 'Bitcoin' },
        'ETH': { korean_name: 'ì´ë”ë¦¬ì›€', english_name: 'Ethereum' },
        'XRP': { korean_name: 'ì—‘ìŠ¤ì•Œí”¼', english_name: 'XRP' },
        'BCH': { korean_name: 'ë¹„íŠ¸ì½”ì¸ ìºì‹œ', english_name: 'Bitcoin Cash' },
        'ETC': { korean_name: 'ì´ë”ë¦¬ì›€ í´ë˜ì‹', english_name: 'Ethereum Classic' },
        'QTUM': { korean_name: 'í€€í…€', english_name: 'Qtum' },
        'A': { korean_name: 'ë³¼íƒ€', english_name: 'Vaulta' },
        'ICX': { korean_name: 'ì•„ì´ì½˜', english_name: 'ICON' },
        'TRX': { korean_name: 'íŠ¸ë¡ ', english_name: 'TRON' },
        'ELF': { korean_name: 'ì—˜í”„', english_name: 'aelf' },
        'KNC': { korean_name: 'ì¹´ì´ë²„ ë„¤íŠ¸ì›Œí¬', english_name: 'Kyber Network' },
        'GLM': { korean_name: 'ê³¨ë ˜', english_name: 'Golem' },
        'ZIL': { korean_name: 'ì§ˆë¦¬ì¹´', english_name: 'Zilliqa' },
        'WAXP': { korean_name: 'ì™ìŠ¤', english_name: 'WAXP' },
        'POWR': { korean_name: 'íŒŒì›Œë ›ì €', english_name: 'Powerledger' },
        'LRC': { korean_name: 'ë£¨í”„ë§', english_name: 'Loopring' },
        'STEEM': { korean_name: 'ìŠ¤íŒ€', english_name: 'Steem' },
        'ZRX': { korean_name: 'ì œë¡œì—‘ìŠ¤', english_name: '0x' },
        'SNT': { korean_name: 'ìŠ¤í…Œì´í„°ìŠ¤ë„¤íŠ¸ì›Œí¬í† í°', english_name: 'Status Network' },
        'ADA': { korean_name: 'ì—ì´ë‹¤', english_name: 'Cardano' },
        'LINK': { korean_name: 'ì²´ì¸ë§í¬', english_name: 'ChainLink' },
        'UNI': { korean_name: 'ìœ ë‹ˆìŠ¤ì™‘', english_name: 'Uniswap' },
        'SAND': { korean_name: 'ìƒŒë“œë°•ìŠ¤', english_name: 'The Sandbox' },
        'MANA': { korean_name: 'ë””ì„¼íŠ¸ëŸ´ëœë“œ', english_name: 'Decentraland' },
        'SUSHI': { korean_name: 'ìŠ¤ì‹œìŠ¤ì™‘', english_name: 'Sushiswap' }
      };
    }

    // 5. ì ìˆ˜ íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸
    function updateScoreHistory(symbol, score) {
      const now = new Date();
      const timeKey = Math.floor(now.getTime() / (5 * 60 * 1000)) * 5; // 5ë¶„ ë‹¨ìœ„
      
      if (!scoreHistory[symbol]) {
        scoreHistory[symbol] = [];
      }
      
      // ì¤‘ë³µ ì‹œê°„ ì²´í¬ (ê°™ì€ 5ë¶„ êµ¬ê°„ì— ì´ë¯¸ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ì—…ë°ì´íŠ¸)
      const existingIndex = scoreHistory[symbol].findIndex(item => item.time === timeKey);
      if (existingIndex !== -1) {
        scoreHistory[symbol][existingIndex] = {
          time: timeKey,
          score: score,
          timestamp: now.toISOString()
        };
      } else {
        scoreHistory[symbol].push({
          time: timeKey,
          score: score,
          timestamp: now.toISOString()
        });
      }
      
      // ìµœê·¼ 24ì‹œê°„ ë°ì´í„°ë§Œ ìœ ì§€
      const oneDayAgo = now.getTime() - (24 * 60 * 60 * 1000);
      scoreHistory[symbol] = scoreHistory[symbol].filter(
        item => item.time * 5 * 60 * 1000 > oneDayAgo
      );
      
      localStorage.setItem('scoreHistory', JSON.stringify(scoreHistory));
    }

    // 6. ì ìˆ˜ ì•ˆì •ì„± ê³„ì‚°
    function calculateScoreStability(symbol) {
      const history = scoreHistory[symbol] || [];
      if (history.length < 3) return { stability: 'insufficient_data', avgScore: 0, stdDev: 0 };
      
      const scores = history.slice(-12).map(h => h.score); // ìµœê·¼ 12ê°œ (1ì‹œê°„)
      const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;
      const variance = scores.reduce((sum, score) => sum + Math.pow(score - avgScore, 2), 0) / scores.length;
      const stdDev = Math.sqrt(variance);
      
      let stability;
      if (stdDev < 3) stability = 'very_stable';
      else if (stdDev < 6) stability = 'stable';
      else if (stdDev < 10) stability = 'moderate';
      else stability = 'volatile';
      
      return { stability, avgScore: Math.round(avgScore), stdDev: Math.round(stdDev) };
    }

    // 7. íŠ¸ë Œë“œ ë¶„ì„
    function calculateTrend(symbol) {
      const history = scoreHistory[symbol] || [];
      if (history.length < 6) return 'insufficient_data';
      
      const recent = history.slice(-6);
      const early = recent.slice(0, 3).map(h => h.score);
      const late = recent.slice(-3).map(h => h.score);
      
      const earlyAvg = early.reduce((a, b) => a + b, 0) / early.length;
      const lateAvg = late.reduce((a, b) => a + b, 0) / late.length;
      
      const trendStrength = ((lateAvg - earlyAvg) / earlyAvg) * 100;
      
      if (trendStrength > 5) return 'upward';
      if (trendStrength < -5) return 'downward';
      return 'sideways';
    }

    // 8. ì¡°ì •ëœ ì¶”ì²œ ê³„ì‚°
    function getAdjustedRecommendation(score, stability, trend) {
      let baseRecommendation = getRecommendation(score);
      let adjustedStrength = 1.0;
      
      // ì•ˆì •ì„±ì— ë”°ë¥¸ ì¡°ì •
      switch(stability) {
        case 'very_stable':
          adjustedStrength *= 1.2;
          break;
        case 'stable':
          adjustedStrength *= 1.1;
          break;
        case 'moderate':
          adjustedStrength *= 0.9;
          break;
        case 'volatile':
          adjustedStrength *= 0.7;
          break;
      }
      
      // íŠ¸ë Œë“œì— ë”°ë¥¸ ì¡°ì •
      if (trend === 'upward' && score >= 70) adjustedStrength *= 1.15;
      else if (trend === 'downward') adjustedStrength *= 0.8;
      
      // ìµœì¢… ì¶”ì²œ ê²°ì •
      const adjustedScore = score * adjustedStrength;
      
      if (adjustedScore >= 85 && stability === 'very_stable') return 'ğŸ”¥ ê°•ë ¥ë§¤ìˆ˜';
      if (adjustedScore >= 75 && (stability === 'very_stable' || stability === 'stable')) return 'ğŸ’ª ì ê·¹ë§¤ìˆ˜';
      if (adjustedScore >= 65 && stability !== 'volatile') return baseRecommendation;
      if (adjustedScore < 50 || stability === 'volatile') return 'âš ï¸ ì‹ ì¤‘ê²€í† ';
      
      return baseRecommendation;
    }

    // 9. ë§¤ìˆ˜ ì‹ í˜¸ ì²´í¬
    function checkBuySignal(coinData) {
      const { symbol, investmentScore, stability, trend } = coinData;
      
      // ê°•ë ¥í•œ ë§¤ìˆ˜ ì‹ í˜¸ ì¡°ê±´ë“¤
      const conditions = {
        highScore: investmentScore >= 75,
        stable: stability === 'very_stable' || stability === 'stable',
        positiveOrSidewaysTrend: trend === 'upward' || trend === 'sideways',
        veryHighScore: investmentScore >= 85
      };
      
      const conditionsMet = Object.values(conditions).filter(Boolean).length;
      
      if (conditions.veryHighScore && conditions.stable && conditions.positiveOrSidewaysTrend) {
        return {
          signal: 'strong_buy',
          confidence: 95,
          reasons: getBuyReasons(coinData, conditions)
        };
      } else if (conditionsMet >= 2) {
        return {
          signal: 'strong_buy',
          confidence: Math.round((conditionsMet / 4) * 100),
          reasons: getBuyReasons(coinData, conditions)
        };
      }
      
      return { signal: 'wait', confidence: 0, reasons: [] };
    }

    // 10. ë§¤ìˆ˜ ì´ìœ  ìƒì„±
    function getBuyReasons(coinData, conditions) {
      const reasons = [];
      if (conditions.veryHighScore) reasons.push('ë§¤ìš° ë†’ì€ íˆ¬ìì ìˆ˜(85+)');
      else if (conditions.highScore) reasons.push('ë†’ì€ íˆ¬ìì ìˆ˜(75+)');
      if (coinData.stability === 'very_stable') reasons.push('ë§¤ìš° ì•ˆì •ì ');
      else if (coinData.stability === 'stable') reasons.push('ì•ˆì •ì ');
      if (coinData.trend === 'upward') reasons.push('ìƒìŠ¹ íŠ¸ë Œë“œ');
      else if (coinData.trend === 'sideways') reasons.push('ì•ˆì •ì  íš¡ë³´');
      return reasons;
    }

    // 11. íˆìŠ¤í† ë¦¬ ì´ˆê¸°í™”
    function clearHistory() {
      if (confirm('ëª¨ë“  ì ìˆ˜ íˆìŠ¤í† ë¦¬ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')) {
        localStorage.removeItem('scoreHistory');
        scoreHistory = {};
        showToast('íˆìŠ¤í† ë¦¬ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
        loadCryptoData(); // ë°ì´í„° ë‹¤ì‹œ ë¡œë“œ
      }
    }

    const validUsers = { 'reib': 'reibyeon', 'user': 'friends' };
    let currentUser = null;
    const SESSION_TIMEOUT = 2 * 60 * 60 * 1000;
    let gridApi;
    let allCryptoData = [];
    let currentFilter = 'all';
    let favoriteCoins = JSON.parse(localStorage.getItem('favoriteCoins')) || [];

    document.addEventListener('DOMContentLoaded', async function() {
      console.log('í˜ì´ì§€ ë¡œë”© ì‹œì‘');
      await loadMarketInfo();
      console.log('ë§ˆì¼“ ì •ë³´ ë¡œë”© ì™„ë£Œ');
      checkLoginStatus();
      setupLoginForm();
    });

    // ìœˆë„ìš° í¬ê¸° ë³€ê²½ ì‹œ ê·¸ë¦¬ë“œ í¬ê¸° ì¬ì¡°ì •
    window.addEventListener('resize', function() {
      if (gridApi) {
        setTimeout(() => {
          gridApi.sizeColumnsToFit();
        }, 100);
      }
    });

    // í™”ë©´ ë°©í–¥ ë³€ê²½ ì‹œì—ë„ í¬ê¸° ì¬ì¡°ì •
    window.addEventListener('orientationchange', function() {
      if (gridApi) {
        setTimeout(() => {
          gridApi.sizeColumnsToFit();
        }, 300);
      }
    });

    function checkLoginStatus() {
      const loginData = localStorage.getItem('cryptoTradingLogin');
      if (loginData) {
        try {
          const { username, loginTime } = JSON.parse(loginData);
          const now = new Date().getTime();
          if (now - loginTime < SESSION_TIMEOUT) {
            currentUser = username;
            showMainScreen();
            return;
          } else {
            localStorage.removeItem('cryptoTradingLogin');
            showToast('ì„¸ì…˜ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.');
          }
        } catch (e) {
          localStorage.removeItem('cryptoTradingLogin');
        }
      }
      showLoginScreen();
    }

    function setupLoginForm() {
      const loginForm = document.getElementById('loginForm');
      loginForm.addEventListener('submit', function(e) {
        e.preventDefault();
        attemptLogin();
      });
      document.getElementById('username').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') document.getElementById('password').focus();
      });
      document.getElementById('password').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') attemptLogin();
      });
    }

    function attemptLogin() {
      const username = document.getElementById('username').value.trim();
      const password = document.getElementById('password').value;
      if (!username || !password) {
        showError('ì‚¬ìš©ìëª…ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.');
        return;
      }
      if (validUsers[username] && validUsers[username] === password) {
        currentUser = username;
        const loginData = { username: username, loginTime: new Date().getTime() };
        localStorage.setItem('cryptoTradingLogin', JSON.stringify(loginData));
        hideError();
        showMainScreen();
        showToast(`${username}ë‹˜, í™˜ì˜í•©ë‹ˆë‹¤!`);
      } else {
        showError('ì‚¬ìš©ìëª… ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
        document.getElementById('password').value = '';
        document.getElementById('password').focus();
      }
    }

    function logout() {
      localStorage.removeItem('cryptoTradingLogin');
      currentUser = null;
      showLoginScreen();
      showToast('ë¡œê·¸ì•„ì›ƒë˜ì—ˆìŠµë‹ˆë‹¤.');
    }

    function showLoginScreen() {
      document.getElementById('loginScreen').classList.remove('hidden');
      document.getElementById('mainScreen').classList.add('hidden');
      document.getElementById('username').focus();
    }

    function showMainScreen() {
      document.getElementById('loginScreen').classList.add('hidden');
      document.getElementById('mainScreen').classList.remove('hidden');
      
      const welcomeMsg = {
        'reib': 'ğŸ‘‘ ê´€ë¦¬ìë‹˜, í™˜ì˜í•©ë‹ˆë‹¤!',
        'user': 'ğŸ‘¤ ì‚¬ìš©ìë‹˜, í™˜ì˜í•©ë‹ˆë‹¤!'
      };
      document.getElementById('userWelcome').textContent = welcomeMsg[currentUser] || `${currentUser}ë‹˜, í™˜ì˜í•©ë‹ˆë‹¤!`;
      
      setTimeout(() => {
        if (!gridApi) {
          const gridDiv = document.getElementById('myGrid');
          gridApi = agGrid.createGrid(gridDiv, gridOptions);
          document.getElementById('allCoinsBtn').classList.add('active');
        }
        
        setTimeout(() => {
          if (gridApi) {
            gridApi.sizeColumnsToFit();
          }
        }, 200);
      }, 100);
    }

    function showError(message) {
      const errorDiv = document.getElementById('errorMessage');
      errorDiv.textContent = message;
      errorDiv.classList.remove('hidden');
    }

    function hideError() {
      const errorDiv = document.getElementById('errorMessage');
      errorDiv.classList.add('hidden');
    }

    function showToast(message) {
      const existingToast = document.querySelector('.toast');
      if (existingToast) existingToast.remove();
      const toast = document.createElement('div');
      toast.className = 'toast';
      toast.textContent = message;
      document.body.appendChild(toast);
      setTimeout(() => { toast.remove(); }, 4000);
    }

    let activityTimer;
    function resetActivityTimer() {
      clearTimeout(activityTimer);
      activityTimer = setTimeout(() => {
        if (currentUser) {
          const loginData = { username: currentUser, loginTime: new Date().getTime() };
          localStorage.setItem('cryptoTradingLogin', JSON.stringify(loginData));
        }
      }, 30000);
    }
    ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'].forEach(event => {
      document.addEventListener(event, resetActivityTimer, true);
    });

    function updateDateTime() {
      const now = new Date();
      const options = {
        year: 'numeric', month: 'long', day: 'numeric',
        hour: '2-digit', minute: '2-digit', second: '2-digit',
        weekday: 'long', timeZone: 'Asia/Seoul'
      };
      const dateTimeString = now.toLocaleDateString('ko-KR', options);
      const datetimeElement = document.getElementById('datetime');
      if (datetimeElement) {
        datetimeElement.textContent = `ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ${dateTimeString}`;
      }
    }
    setInterval(updateDateTime, 1000);
    updateDateTime();

    function getTradingParams(score) {
      if (score >= 80) return { profitRate: 8, stopLoss: 3, tradable: true };
      if (score >= 70) return { profitRate: 6, stopLoss: 2.5, tradable: true };
      if (score >= 60) return { profitRate: 4, stopLoss: 2, tradable: true };
      if (score >= 50) return { profitRate: 3, stopLoss: 2, tradable: true };
      return { profitRate: 0, stopLoss: 0, tradable: false };
    }

    function calculateTargetPrice(currentPrice, score) {
      const params = getTradingParams(score);
      if (!params.tradable) return null;
      return Math.round(currentPrice * (1 + params.profitRate / 100));
    }

    function calculateStopLoss(currentPrice, score) {
      const params = getTradingParams(score);
      if (!params.tradable) return null;
      return Math.round(currentPrice * (1 - params.stopLoss / 100));
    }

    function calculatePricePosition(data) {
      const current = parseFloat(data.closing_price);
      const min = parseFloat(data.min_price);
      const max = parseFloat(data.max_price);
      if (max === min) return 10;
      const position = (current - min) / (max - min);
      if (position >= 0.3 && position <= 0.7) return 15;
      if (position >= 0.2 && position <= 0.8) return 10;
      if (position >= 0.1 && position <= 0.9) return 5;
      return 0;
    }

    function calculateVolatility(data) {
      const min = parseFloat(data.min_price);
      const max = parseFloat(data.max_price);
      const opening = parseFloat(data.opening_price);
      if (opening === 0) return 0;
      const volatility = ((max - min) / opening) * 100;
      if (volatility >= 2 && volatility <= 8) return 10;
      if (volatility >= 1 && volatility <= 12) return 7;
      if (volatility >= 0.5 && volatility <= 15) return 4;
      return 0;
    }

    function calculateMomentum(data) {
      const rate24h = parseFloat(data.fluctate_rate_24H);
      const current = parseFloat(data.closing_price);
      const opening = parseFloat(data.opening_price);
      if (opening === 0) return 0;
      const dailyChange = ((current - opening) / opening) * 100;
      if (rate24h > 0 && rate24h <= 5 && dailyChange > 0) return 15;
      if (rate24h > 0 && rate24h <= 10) return 10;
      if (rate24h > -2 && rate24h <= 1) return 7;
      if (rate24h > -5 && rate24h <= -2) return 3;
      return 0;
    }

    function calculateVolumeHealth(data) {
      const volume = parseFloat(data.units_traded);
      const value = parseFloat(data.acc_trade_value);
      if (volume === 0 || value === 0) return 0;
      const avgPrice = value / volume;
      const currentPrice = parseFloat(data.closing_price);
      if (currentPrice === 0) return 0;
      const priceDeviation = Math.abs(currentPrice - avgPrice) / currentPrice;
      if (priceDeviation <= 0.01) return 15;
      if (priceDeviation <= 0.03) return 10;
      if (priceDeviation <= 0.05) return 5;
      return 0;
    }

    function calculateVolumeGrowth(data) {
      const volume = parseFloat(data.units_traded);
      const volume24h = parseFloat(data.units_traded_24H);
      if (volume === 0) return 0;
      if (volume24h > volume * 1.2) return 10;
      if (volume24h > volume * 1.1) return 7;
      if (volume24h > volume * 1.05) return 4;
      return 0;
    }

    function calculateStability(data) {
      const current = parseFloat(data.closing_price);
      const prev = parseFloat(data.prev_closing_price);
      if (prev === 0) return 0;
      const change = Math.abs((current - prev) / prev) * 100;
      if (change <= 3) return 10;
      if (change <= 7) return 6;
      if (change <= 15) return 2;
      return 0;
    }

    function calculateSupportLevel(data) {
      const current = parseFloat(data.closing_price);
      const min = parseFloat(data.min_price);
      const max = parseFloat(data.max_price);
      if (max === min) return 5;
      const distanceFromMin = (current - min) / (max - min);
      if (distanceFromMin >= 0.1 && distanceFromMin <= 0.3) return 10;
      if (distanceFromMin >= 0.05 && distanceFromMin <= 0.4) return 7;
      if (distanceFromMin >= 0.4 && distanceFromMin <= 0.6) return 4;
      return 0;
    }

    function calculateMarketPosition(allCoins, currentCoin) {
      const values = allCoins.map(coin => parseFloat(coin.acc_trade_value));
      values.sort((a, b) => b - a);
      const currentValue = parseFloat(currentCoin.acc_trade_value);
      const rank = values.indexOf(currentValue) + 1;
      const percentile = (values.length - rank) / values.length;
      if (percentile >= 0.9) return 15;
      if (percentile >= 0.7) return 12;
      if (percentile >= 0.5) return 8;
      if (percentile >= 0.3) return 4;
      return 0;
    }

    function calculateInvestmentScore(coinData, allCoinsData) {
      const pricePosition = calculatePricePosition(coinData);
      const volatility = calculateVolatility(coinData);
      const momentum = calculateMomentum(coinData);
      const volumeHealth = calculateVolumeHealth(coinData);
      const volumeGrowth = calculateVolumeGrowth(coinData);
      const stability = calculateStability(coinData);
      const supportLevel = calculateSupportLevel(coinData);
      const marketPosition = calculateMarketPosition(allCoinsData, coinData);
      const totalScore = pricePosition + volatility + momentum + volumeHealth +
                        volumeGrowth + stability + supportLevel + marketPosition;
      return {
        totalScore,
        grade: getGrade(totalScore),
        recommendation: getRecommendation(totalScore),
        breakdown: {
          technical: pricePosition + volatility + momentum,
          volume: volumeHealth + volumeGrowth,
          risk: stability + supportLevel,
          market: marketPosition
        }
      };
    }

    function getGrade(score) {
      if (score >= 80) return 'A+';
      if (score >= 70) return 'A';
      if (score >= 60) return 'B+';
      if (score >= 50) return 'B';
      if (score >= 40) return 'C';
      return 'D';
    }

    function getRecommendation(score) {
      if (score >= 75) return 'ê°•ë ¥ ë§¤ìˆ˜';
      if (score >= 65) return 'ë§¤ìˆ˜';
      if (score >= 55) return 'ë³´ìœ ';
      if (score >= 45) return 'ê´€ë§';
      return 'ë§¤ë„ ê³ ë ¤';
    }

    function toggleFavorite(symbol) {
      const index = favoriteCoins.indexOf(symbol);
      const wasRemoved = index > -1;
      if (wasRemoved) {
        favoriteCoins.splice(index, 1);
      } else {
        favoriteCoins.push(symbol);
      }
      localStorage.setItem('favoriteCoins', JSON.stringify(favoriteCoins));
      gridApi.refreshCells({ force: true, columns: ['symbol'] });
      gridApi.redrawRows();
      if (currentFilter === 'favorites') applyFilter();
      const info = marketInfoMap[symbol] || {};
      const coinName = info.korean_name || symbol;
      const message = wasRemoved 
        ? `${coinName}(${symbol})ì´ ê´€ì‹¬ ì½”ì¸ì—ì„œ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.`
        : `${coinName}(${symbol})ì´ ê´€ì‹¬ ì½”ì¸ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.`;
      showToast(message);
    }

    function toggleFilter(filterType) {
      currentFilter = filterType;
      document.getElementById('allCoinsBtn').classList.toggle('active', filterType === 'all');
      document.getElementById('favoritesBtn').classList.toggle('active', filterType === 'favorites');
      document.getElementById('recommendedBtn').classList.toggle('active', filterType === 'recommended');
      document.getElementById('signalsBtn').classList.toggle('active', filterType === 'signals');
      applyFilter();
    }

    function applyFilter() {
      let filteredData = allCryptoData;
      if (currentFilter === 'favorites') {
        filteredData = allCryptoData.filter(coin => favoriteCoins.includes(coin.symbol));
      } else if (currentFilter === 'recommended') {
        filteredData = [...allCryptoData]
          .sort((a, b) => (b.investmentScore || 0) - (a.investmentScore || 0))
          .slice(0, 10);
      } else if (currentFilter === 'signals') {
        filteredData = allCryptoData.filter(coin => 
          coin.buySignal && coin.buySignal.signal === 'strong_buy' && coin.buySignal.confidence >= 50
        );
      }
      if (gridApi) {
        gridApi.setGridOption('rowData', filteredData);
        updateCoinCount(filteredData.length);
        setTimeout(() => {
          gridApi.sizeColumnsToFit();
        }, 100);
      }
    }

    function updateCoinCount(count) {
      const totalCount = allCryptoData.length;
      const favoriteCount = favoriteCoins.length;
      const signalCount = allCryptoData.filter(coin => 
        coin.buySignal && coin.buySignal.signal === 'strong_buy' && coin.buySignal.confidence >= 50
      ).length;
      
      let countText = '';
      if (currentFilter === 'all') {
        countText = `ì „ì²´ ${totalCount}ê°œ ì½”ì¸ (ê´€ì‹¬ ${favoriteCount}ê°œ, ë§¤ìˆ˜ì‹ í˜¸ ${signalCount}ê°œ)`;
      } else if (currentFilter === 'favorites') {
        countText = `ê´€ì‹¬ ì½”ì¸ ${count}ê°œ / ì „ì²´ ${totalCount}ê°œ`;
      } else if (currentFilter === 'recommended') {
        countText = `ì¶”ì²œ ì½”ì¸ ${count}ê°œ (íˆ¬ìì ìˆ˜ ìƒìœ„ 10ê°œ)`;
      } else if (currentFilter === 'signals') {
        countText = `ë§¤ìˆ˜ ì‹ í˜¸ ${count}ê°œ / ì „ì²´ ${totalCount}ê°œ`;
      }
      
      const countElement = document.getElementById('coinCount');
      if (countElement) {
        countElement.textContent = countText;
      }
    }

    const formatPrice = (value) => {
      if (!value || value === '0') return '0';
      return parseFloat(value).toLocaleString('ko-KR') + ' ì›';
    };

    const formatVolume = (value) => {
      if (!value || value === '0') return '0';
      const num = parseFloat(value);
      if (num >= 1000000) return (num/1000000).toFixed(2) + 'M';
      if (num >= 1000) return (num/1000).toFixed(2) + 'K';
      return num.toFixed(4);
    };

    const formatRate = (value) => {
      if (!value || value === '0') return '0.00%';
      const rate = parseFloat(value);
      return (rate > 0 ? '+' : '') + rate.toFixed(2) + '%';
    };

    const symbolCellRenderer = (params) => {
      const symbol = params.value;
      const isFavorite = favoriteCoins.includes(symbol);
      const starIcon = isFavorite ? 'â˜…' : 'â˜†';
      const starClass = isFavorite ? 'active' : 'inactive';
      
      const marketInfo = marketInfoMap[symbol] || {};
      const koreanName = marketInfo.korean_name || symbol;
      
      return `
        <div class="symbol-cell">
          <span class="favorite-star ${starClass}" 
                onclick="toggleFavorite('${symbol}')"
                title="${isFavorite ? 'ê´€ì‹¬ ì½”ì¸ì—ì„œ ì œê±°' : 'ê´€ì‹¬ ì½”ì¸ì— ì¶”ê°€'}"
                data-symbol="${symbol}">
            ${starIcon}
          </span>
          <div class="symbol-info">
            <div style="font-weight: bold; font-size: 14px; margin: 0; line-height: 1.2;">${symbol}</div>
            <div class="coin-name" style="margin: 0; line-height: 1.2;">${koreanName}</div>
          </div>
        </div>
      `;
    };

    const scoreCellRenderer = (params) => {
      const score = params.value || 0;
      const grade = params.data.grade || 'D';
      const gradeClass = `grade-${grade.replace('+', '-plus')}`;
      return `
        <div class="score-cell ${gradeClass}">
          <div style="text-align: center;">
            <div style="font-size: 16px; margin: 0; line-height: 1.2;">${score}</div>
            <div style="font-size: 12px; margin: 0; line-height: 1.2;">${grade}</div>
          </div>
        </div>
      `;
    };

    const stabilityCellRenderer = (params) => {
      const stability = params.data.stability;
      const avgScore = params.data.avgScore;
      const stdDev = params.data.stdDev;
      
      let color, icon, text, className;
      switch(stability) {
        case 'very_stable':
          color = '#28a745'; icon = 'ğŸŸ¢'; text = 'ë§¤ìš°ì•ˆì •'; className = 'stability-very-stable';
          break;
        case 'stable':
          color = '#17a2b8'; icon = 'ğŸ”µ'; text = 'ì•ˆì •'; className = 'stability-stable';
          break;
        case 'moderate':
          color = '#ffc107'; icon = 'ğŸŸ¡'; text = 'ë³´í†µ'; className = 'stability-moderate';
          break;
        case 'volatile':
          color = '#dc3545'; icon = 'ğŸ”´'; text = 'ë³€ë™í¼'; className = 'stability-volatile';
          break;
        default:
          color = '#6c757d'; icon = 'âšª'; text = 'ë°ì´í„°ë¶€ì¡±'; className = 'stability-insufficient';
      }
      
      return `
        <div class="${className}" style="color: ${color}; text-align: center; font-size: 11px;">
          <div style="margin: 0; line-height: 1.2;">${icon} ${text}</div>
          <div style="font-size: 10px; color: #666; margin: 0; line-height: 1.2;">í‰ê· : ${avgScore}</div>
        </div>
      `;
    };

    const trendCellRenderer = (params) => {
      const trend = params.data.trend;
      let color, icon, text, className;
      
      switch(trend) {
        case 'upward':
          color = '#28a745'; icon = 'ğŸ“ˆ'; text = 'ìƒìŠ¹'; className = 'trend-upward';
          break;
        case 'downward':
          color = '#dc3545'; icon = 'ğŸ“‰'; text = 'í•˜ë½'; className = 'trend-downward';
          break;
        case 'sideways':
          color = '#6c757d'; icon = 'â¡ï¸'; text = 'íš¡ë³´'; className = 'trend-sideways';
          break;
        default:
          color = '#6c757d'; icon = 'â“'; text = 'ë¶ˆëª…'; className = 'trend-sideways';
      }
      
      return `
        <div class="${className}" style="color: ${color}; text-align: center; font-size: 12px;">
          <div style="margin: 0; line-height: 1.2;">${icon} ${text}</div>
        </div>
      `;
    };

    const buySignalCellRenderer = (params) => {
      const buySignal = params.data.buySignal;
      if (!buySignal || buySignal.signal === 'wait') {
        return '<div class="buy-signal-wait" style="text-align: center; font-size: 12px; color: #6c757d;">ëŒ€ê¸°</div>';
      }
      
      const confidence = buySignal.confidence;
      const reasons = buySignal.reasons.slice(0, 2).join(', ');
      
      return `
        <div class="buy-signal-strong" style="text-align: center; font-size: 11px;">
          <div style="font-weight: bold; color: #dc3545; margin: 0; line-height: 1.2;">ğŸš€ ${confidence}%</div>
          <div style="font-size: 10px; color: #666; margin: 0; line-height: 1.2;" title="${buySignal.reasons.join(', ')}">${reasons}</div>
        </div>
      `;
    };

    const targetPriceCellRenderer = (params) => {
      const currentPrice = parseFloat(params.data.closing_price);
      const score = params.data.investmentScore || 0;
      const targetPrice = calculateTargetPrice(currentPrice, score);
      if (!targetPrice) {
        return '<div class="no-trade">ë§¤ìˆ˜ ì œì™¸</div>';
      }
      const params_trading = getTradingParams(score);
      return `
        <div class="target-price">
          <div style="font-size: 14px; font-weight: bold; margin: 0; line-height: 1.2;">${targetPrice.toLocaleString('ko-KR')}ì›</div>
          <div style="font-size: 11px; color: #666; margin: 0; line-height: 1.2;">(+${params_trading.profitRate}%)</div>
        </div>
      `;
    };

    const stopLossCellRenderer = (params) => {
      const currentPrice = parseFloat(params.data.closing_price);
      const score = params.data.investmentScore || 0;
      const stopLoss = calculateStopLoss(currentPrice, score);
      if (!stopLoss) {
        return '<div class="no-trade">-</div>';
      }
      const params_trading = getTradingParams(score);
      return `
        <div class="stop-loss">
          <div style="font-size: 14px; font-weight: bold; margin: 0; line-height: 1.2;">${stopLoss.toLocaleString('ko-KR')}ì›</div>
          <div style="font-size: 11px; color: #666; margin: 0; line-height: 1.2;">(-${params_trading.stopLoss}%)</div>
        </div>
      `;
    };

    const gridOptions = {
      columnDefs: [
        { 
          field: 'symbol', 
          headerName: 'ì•”í˜¸í™”í', 
          width: 160, 
          pinned: 'left',
          cellRenderer: symbolCellRenderer,
          cellStyle: { padding: '10px' }
        },
        { 
          field: 'investmentScore', 
          headerName: 'íˆ¬ìì ìˆ˜', 
          width: 90, 
          cellRenderer: scoreCellRenderer,
          sort: 'desc'
        },
        {
          field: 'stability',
          headerName: 'ì•ˆì •ì„±',
          width: 100,
          cellRenderer: stabilityCellRenderer,
          cellStyle: { textAlign: 'center', padding: '5px' }
        },
        {
          field: 'trend',
          headerName: 'íŠ¸ë Œë“œ',
          width: 90,
          cellRenderer: trendCellRenderer,
          cellStyle: { textAlign: 'center', padding: '5px' }
        },
        {
          field: 'buySignal',
          headerName: 'ë§¤ìˆ˜ì‹ í˜¸',
          width: 100,
          cellRenderer: buySignalCellRenderer,
          cellStyle: { textAlign: 'center', padding: '5px' }
        },
        { 
          field: 'closing_price', 
          headerName: 'í˜„ì¬ê°€', 
          width: 130, 
          valueFormatter: params => formatPrice(params.value), 
          cellStyle: { fontWeight: 'bold', color: '#007bff', textAlign: 'right', paddingRight: '10px' }
        },
        { 
          field: 'targetPrice', 
          headerName: 'ëª©í‘œê°€', 
          width: 130, 
          cellRenderer: targetPriceCellRenderer,
          cellStyle: { textAlign: 'center', padding: '5px' }
        },
        { 
          field: 'stopLoss', 
          headerName: 'ì†ì ˆê°€', 
          width: 130, 
          cellRenderer: stopLossCellRenderer,
          cellStyle: { textAlign: 'center', padding: '5px' }
        },
        { 
          field: 'fluctate_rate_24H', 
          headerName: '24H ë³€ë™ë¥ ', 
          width: 110, 
          valueFormatter: params => formatRate(params.value),
          cellStyle: params => ({
            color: parseFloat(params.value) > 0 ? '#dc3545' : parseFloat(params.value) < 0 ? '#007bff' : '#333',
            fontWeight: 'bold',
            textAlign: 'right',
            paddingRight: '10px'
          })
        },
        { 
          field: 'recommendation', 
          headerName: 'ì¶”ì²œ', 
          width: 110, 
          cellStyle: params => {
            const rec = params.value;
            if (rec === 'ğŸ”¥ ê°•ë ¥ë§¤ìˆ˜') return { color: '#dc3545', fontWeight: 'bold', fontSize: '12px' };
            if (rec === 'ğŸ’ª ì ê·¹ë§¤ìˆ˜') return { color: '#fd7e14', fontWeight: 'bold', fontSize: '12px' };
            if (rec === 'ê°•ë ¥ ë§¤ìˆ˜') return { color: '#dc3545', fontWeight: 'bold', fontSize: '12px' };
            if (rec === 'ë§¤ìˆ˜') return { color: '#fd7e14', fontWeight: 'bold', fontSize: '12px' };
            if (rec === 'ë³´ìœ ') return { color: '#28a745', fontWeight: 'bold', fontSize: '12px' };
            if (rec === 'ê´€ë§') return { color: '#6c757d', fontSize: '12px' };
            if (rec === 'âš ï¸ ì‹ ì¤‘ê²€í† ') return { color: '#ffc107', fontSize: '12px' };
            return { color: '#007bff', fontSize: '12px' };
          }
        },
        { 
          field: 'opening_price', 
          headerName: 'ì‹œê°€', 
          width: 120, 
          valueFormatter: params => formatPrice(params.value),
          cellStyle: { textAlign: 'right', paddingRight: '10px', fontSize: '12px' }
        },
        { 
          field: 'min_price', 
          headerName: 'ìµœì €ê°€', 
          width: 120, 
          valueFormatter: params => formatPrice(params.value), 
          cellStyle: { color: '#dc3545', textAlign: 'right', paddingRight: '10px', fontSize: '12px' }
        },
        { 
          field: 'max_price', 
          headerName: 'ìµœê³ ê°€', 
          width: 120, 
          valueFormatter: params => formatPrice(params.value), 
          cellStyle: { color: '#28a745', textAlign: 'right', paddingRight: '10px', fontSize: '12px' }
        }
      ],
      defaultColDef: {
        sortable: true,
        filter: true,
        resizable: true,
        minWidth: 80,
        suppressSizeToFit: false
      },
      rowData: [],
      rowHeight: 60,
      getRowClass: (params) => {
        const classes = [];
        if (favoriteCoins.includes(params.data.symbol)) {
          classes.push('favorite-row');
        }
        if (currentFilter === 'recommended') {
          classes.push('recommended-row');
        }
        if (currentFilter === 'signals' || (params.data.buySignal && params.data.buySignal.signal === 'strong_buy')) {
          classes.push('signal-row');
        }
        return classes.join(' ');
      },
      onGridReady: function(params) {
        gridApi = params.api;
        loadCryptoData();
        
        setTimeout(() => {
          params.api.sizeColumnsToFit();
        }, 300);
      },
      
      onGridSizeChanged: function(params) {
        setTimeout(() => {
          params.api.sizeColumnsToFit();
        }, 50);
      },
      
      onFirstDataRendered: function(params) {
        setTimeout(() => {
          params.api.sizeColumnsToFit();
        }, 100);
      }
    };

    async function loadCryptoData() {
      if (!currentUser) return;
      const loadingDiv = document.getElementById('loading');
      if (loadingDiv) loadingDiv.style.display = 'block';
      
      try {
        const response = await fetch('https://api.bithumb.com/public/ticker/ALL_KRW');
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();
        if (data.status !== '0000') throw new Error('API ì‘ë‹µ ì˜¤ë¥˜: ' + data.message);
        
        const rawData = Object.keys(data.data)
          .filter(symbol => symbol !== 'date')
          .map(symbol => ({
            symbol,
            ...data.data[symbol]
          }));
        
        allCryptoData = rawData.map(coin => {
          const scoreResult = calculateInvestmentScore(coin, rawData);
          const currentPrice = parseFloat(coin.closing_price);
          
          // ì ìˆ˜ íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸
          updateScoreHistory(coin.symbol, scoreResult.totalScore);
          
          // ì•ˆì •ì„± ë° íŠ¸ë Œë“œ ê³„ì‚°
          const stabilityInfo = calculateScoreStability(coin.symbol);
          const trend = calculateTrend(coin.symbol);
          
          // ì¡°ì •ëœ ì¶”ì²œ ê³„ì‚°
          const adjustedRecommendation = getAdjustedRecommendation(
            scoreResult.totalScore, 
            stabilityInfo.stability, 
            trend
          );
          
          // ë§¤ìˆ˜ ì‹ í˜¸ ì²´í¬
          const buySignal = checkBuySignal({
            symbol: coin.symbol,
            investmentScore: scoreResult.totalScore,
            stability: stabilityInfo.stability,
            trend: trend
          });
          
          return {
            ...coin,
            investmentScore: scoreResult.totalScore,
            grade: scoreResult.grade,
            recommendation: adjustedRecommendation,
            stability: stabilityInfo.stability,
            avgScore: stabilityInfo.avgScore,
            stdDev: stabilityInfo.stdDev,
            trend: trend,
            buySignal: buySignal,
            targetPrice: calculateTargetPrice(currentPrice, scoreResult.totalScore),
            stopLoss: calculateStopLoss(currentPrice, scoreResult.totalScore)
          };
        });
        
        // ë§¤ìˆ˜ ì‹ í˜¸ê°€ ìˆëŠ” ì½”ì¸ ì•Œë¦¼
        const strongBuyCoins = allCryptoData.filter(coin => 
          coin.buySignal.signal === 'strong_buy' && coin.buySignal.confidence >= 67
        );
        
        if (strongBuyCoins.length > 0) {
          const coinNames = strongBuyCoins.slice(0, 3).map(coin => {
            const marketInfo = marketInfoMap[coin.symbol] || {};
            return marketInfo.korean_name || coin.symbol;
          });
          showToast(`ğŸš€ ê°•ë ¥ ë§¤ìˆ˜ ì‹ í˜¸: ${coinNames.join(', ')} ë“± ${strongBuyCoins.length}ê°œ ì½”ì¸`);
        }
        
        allCryptoData.sort((a, b) => (b.investmentScore || 0) - (a.investmentScore || 0));
        applyFilter();
        updateDateTime();
        
      } catch (error) {
        console.error('ë°ì´í„° ë¡œë”© ì‹¤íŒ¨:', error);
        showToast('ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        allCryptoData = [];
        applyFilter();
      } finally {
        if (loadingDiv) loadingDiv.style.display = 'none';
      }
    }

    // ìë™ ìƒˆë¡œê³ ì¹¨ (ì„ íƒì‚¬í•­)
    setInterval(() => {
      if (currentUser && document.visibilityState === 'visible') {
        loadCryptoData();
      }
    }, 5 * 60 * 1000); // 5ë¶„ë§ˆë‹¤ ìë™ ìƒˆë¡œê³ ì¹¨
  </script>
</body>
</html>
