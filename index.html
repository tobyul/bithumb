<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ë¹—ì¸ ì‹œì„¸ AG Grid - ìŠ¤ë§ˆíŠ¸ ë§¤ë§¤ ì‹œìŠ¤í…œ</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community/styles/ag-grid.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community/styles/ag-theme-alpine.css" />
  <style>
    body { background: #f5f5f5; font-family: 'Segoe UI', Arial, sans-serif; margin: 0; padding: 20px; }
    .container {
      max-width: 2000px;
      margin: 0 auto;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    h1 { text-align: center; margin-bottom: 10px; color: #333; }
    .datetime-display {
      text-align: center;
      color: #666;
      font-size: 14px;
      margin-bottom: 20px;
      background: #f8f9fa;
      padding: 8px;
      border-radius: 4px;
    }
    .control-panel {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    .refresh-btn, .filter-btn {
      background: #007bff;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 8px 16px;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .refresh-btn:hover, .filter-btn:hover { background: #0056b3; }
    .filter-btn.active { background: #28a745; }
    .filter-btn.favorites { background: #ffc107; color: #333; }
    .filter-btn.favorites:hover { background: #e0a800; }
    .filter-btn.favorites.active { background: #fd7e14; color: #fff; }
    .filter-btn.recommended { background: #dc3545; color: #fff; }
    .filter-btn.recommended:hover { background: #c82333; }
    .filter-btn.recommended.active { background: #bd2130; }
    #myGrid { height: 600px; width: 100%; }
    .loading { text-align: center; color: #666; margin: 20px 0; }
    .coin-name { font-size: 12px; color: #666; }
    
    /* ê°œì„ ëœ ë³„í‘œ ìŠ¤íƒ€ì¼ */
    .favorite-star {
      cursor: pointer;
      font-size: 20px;
      margin-right: 8px;
      transition: all 0.2s ease;
      user-select: none;
      display: inline-block;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      text-align: center;
      line-height: 24px;
    }
    
    .favorite-star.inactive {
      color: #ddd;
      text-shadow: 0 0 1px #999;
      background: transparent;
    }
    
    .favorite-star.active {
      color: #ffc107;
      text-shadow: 0 0 3px rgba(255, 193, 7, 0.5);
      background: rgba(255, 193, 7, 0.1);
      transform: scale(1.1);
    }
    
    .favorite-star:hover {
      color: #ffc107;
      text-shadow: 0 0 3px rgba(255, 193, 7, 0.8);
      transform: scale(1.2);
      background: rgba(255, 193, 7, 0.2);
    }
    
    .favorite-star:active {
      transform: scale(0.9);
    }
    
    .symbol-cell {
      display: flex;
      align-items: center;
      height: 100%;
    }
    .symbol-info {
      flex: 1;
    }
    .coin-count {
      text-align: center;
      color: #666;
      font-size: 12px;
      margin-top: 10px;
    }
    
    /* ê´€ì‹¬ ì½”ì¸ í–‰ í•˜ì´ë¼ì´íŠ¸ */
    .ag-row.favorite-row {
      background-color: #fffbf0 !important;
      border-left: 3px solid #ffc107 !important;
    }
    .ag-row.favorite-row:hover {
      background-color: #fff8e1 !important;
    }
    
    /* ì¶”ì²œ ì½”ì¸ í–‰ í•˜ì´ë¼ì´íŠ¸ */
    .ag-row.recommended-row {
      background-color: #fff5f5 !important;
      border-left: 3px solid #dc3545 !important;
    }
    .ag-row.recommended-row:hover {
      background-color: #ffe6e6 !important;
    }
    
    /* íˆ¬ìì ìˆ˜ ì…€ ìŠ¤íƒ€ì¼ */
    .score-cell {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      font-weight: bold;
      border-radius: 4px;
      margin: 2px;
    }
    
    .grade-A-plus { background: #d4edda; color: #155724; }
    .grade-A { background: #d1ecf1; color: #0c5460; }
    .grade-B-plus { background: #fff3cd; color: #856404; }
    .grade-B { background: #ffeaa7; color: #6c5ce7; }
    .grade-C { background: #f8d7da; color: #721c24; }
    .grade-D { background: #f5c6cb; color: #721c24; }
    
    /* ë§¤ë§¤ ê°€ê²© ì…€ ìŠ¤íƒ€ì¼ */
    .target-price {
      color: #28a745;
      font-weight: bold;
      font-size: 13px;
    }
    
    .stop-loss {
      color: #dc3545;
      font-weight: bold;
      font-size: 13px;
    }
    
    .no-trade {
      color: #6c757d;
      font-style: italic;
      font-size: 12px;
    }
    
    /* í† ìŠ¤íŠ¸ ë©”ì‹œì§€ ìŠ¤íƒ€ì¼ */
    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #333;
      color: white;
      padding: 12px 20px;
      border-radius: 4px;
      z-index: 1000;
      animation: slideIn 0.3s ease-out;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    
    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸª™ ë¹—ì¸ ì•”í˜¸í™”í ìŠ¤ë§ˆíŠ¸ ë§¤ë§¤ ì‹œìŠ¤í…œ</h1>
    <div id="datetime" class="datetime-display"></div>
    
    <div class="control-panel">
      <button class="refresh-btn" onclick="loadCryptoData()">ğŸ”„ ìƒˆë¡œê³ ì¹¨</button>
      <button class="filter-btn" id="allCoinsBtn" onclick="toggleFilter('all')">ğŸ“Š ì „ì²´ ì½”ì¸</button>
      <button class="filter-btn favorites" id="favoritesBtn" onclick="toggleFilter('favorites')">â­ ê´€ì‹¬ ì½”ì¸</button>
      <button class="filter-btn recommended" id="recommendedBtn" onclick="toggleFilter('recommended')">ğŸ¯ ì¶”ì²œ ì½”ì¸</button>
    </div>
    
    <div id="loading" class="loading" style="display: none;">ë°ì´í„° ë¡œë”© ì¤‘...</div>
    <div id="myGrid" class="ag-theme-alpine"></div>
    <div id="coinCount" class="coin-count"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/ag-grid-community/dist/ag-grid-community.min.js"></script>
  <script>
    let gridApi;
    let allCryptoData = [];
    let currentFilter = 'all';
    let favoriteCoins = JSON.parse(localStorage.getItem('favoriteCoins')) || [];

    // ì‹¤ì‹œê°„ ì‹œê°„ ì—…ë°ì´íŠ¸
    function updateDateTime() {
      const now = new Date();
      const options = {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        weekday: 'long',
        timeZone: 'Asia/Seoul'
      };
      const dateTimeString = now.toLocaleDateString('ko-KR', options);
      document.getElementById('datetime').textContent = `ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ${dateTimeString}`;
    }

    setInterval(updateDateTime, 1000);
    updateDateTime();

    // ì•”í˜¸í™”í ì‹¬ë³¼ê³¼ í•œêµ­ì–´ ì´ë¦„ ë§¤í•‘
    const coinNames = {
      'BTC': 'ë¹„íŠ¸ì½”ì¸', 'ETH': 'ì´ë”ë¦¬ì›€', 'XRP': 'ë¦¬í”Œ', 'BCH': 'ë¹„íŠ¸ì½”ì¸ìºì‹œ', 'LTC': 'ë¼ì´íŠ¸ì½”ì¸',
      'EOS': 'ì´ì˜¤ìŠ¤', 'ETC': 'ì´ë”ë¦¬ì›€í´ë˜ì‹', 'XLM': 'ìŠ¤í…”ë¼ë£¨ë©˜', 'ADA': 'ì—ì´ë‹¤', 'DOT': 'í´ì¹´ë‹·',
      'LINK': 'ì²´ì¸ë§í¬', 'TRX': 'íŠ¸ë¡ ', 'VET': 'ë¹„ì²´ì¸', 'THETA': 'ì‹œíƒ€', 'BNB': 'ë°”ì´ë‚¸ìŠ¤ì½”ì¸',
      'MATIC': 'í´ë¦¬ê³¤', 'SOL': 'ì†”ë¼ë‚˜', 'AVAX': 'ì•„ë°œë€ì²´', 'DOGE': 'ë„ì§€ì½”ì¸', 'SHIB': 'ì‹œë°”ì´ëˆ„',
      'UNI': 'ìœ ë‹ˆìŠ¤ì™‘', 'ATOM': 'ì½”ìŠ¤ëª¨ìŠ¤', 'ALGO': 'ì•Œê³ ëœë“œ', 'ICP': 'ì¸í„°ë„·ì»´í“¨í„°', 'FIL': 'íŒŒì¼ì½”ì¸',
      'AAVE': 'ì—ì´ë¸Œ', 'COMP': 'ì»´íŒŒìš´ë“œ', 'MKR': 'ë©”ì´ì»¤', 'SUSHI': 'ìŠ¤ì‹œìŠ¤ì™‘', 'CRV': 'ì»¤ë¸Œ',
      'BAT': 'ë² ì´ì§ì–´í…ì…˜í† í°', 'ZRX': 'ì œë¡œì—‘ìŠ¤', 'MANA': 'ë””ì„¼íŠ¸ëŸ´ëœë“œ', 'SAND': 'ìƒŒë“œë°•ìŠ¤', 'ENJ': 'ì—”ì§„ì½”ì¸',
      'CHZ': 'ì¹ ë¦¬ì¦ˆ', 'FLOW': 'í”Œë¡œìš°', 'KLAY': 'í´ë ˆì´íŠ¼', 'WEMIX': 'ìœ„ë¯¹ìŠ¤', 'QTUM': 'í€€í…€',
      'LSK': 'ë¦¬ìŠ¤í¬', 'STEEM': 'ìŠ¤íŒ€', 'STRAX': 'ìŠ¤íŠ¸ë¼í‹°ìŠ¤', 'ARDR': 'ì•„ë”', 'STORJ': 'ìŠ¤í† ë¦¬ì§€',
      'GRT': 'ë”ê·¸ë˜í”„', 'BAL': 'ë°¸ëŸ°ì„œ', 'REN': 'ë Œ', 'KNC': 'ì¹´ì´ë²„ë„¤íŠ¸ì›Œí¬', 'ZIL': 'ì§ˆë¦¬ì¹´',
      'WAVES': 'ì›¨ì´ë¸Œ', 'ICX': 'ì•„ì´ì½˜', 'OMG': 'ì˜¤ë¯¸ì„¸ê³ ', 'ANKR': 'ì•µì»¤', 'CTC': 'í¬ë ˆë”§ì½”ì¸',
      'TON': 'í†¤ì½”ì¸', 'BLUR': 'ë¸”ëŸ¬', 'PEPE': 'í˜í˜', 'APT': 'ì•±í† ìŠ¤', 'OP': 'ì˜µí‹°ë¯¸ì¦˜',
      'ARB': 'ì•„ë¹„íŠ¸ëŸ¼', 'SUI': 'ìˆ˜ì´', 'WLD': 'ì›”ë“œì½”ì¸', 'TIA': 'ì…€ë ˆìŠ¤í‹°ì•„', 'NEAR': 'ë‹ˆì–´í”„ë¡œí† ì½œ',
      'FTM': 'íŒ¬í…€', 'IMX': 'ì´ë®¤í„°ë¸”ì—‘ìŠ¤', 'INJ': 'ì¸ì í‹°ë¸Œ', 'LUNC': 'ë£¨ë‚˜í´ë˜ì‹', 'LUNA': 'ë£¨ë‚˜',
      'APE': 'ì—ì´í”„ì½”ì¸', 'GALA': 'ê°ˆë¼', 'AXS': 'ì•¡ì‹œì¸í”¼ë‹ˆí‹°', 'GMT': 'ìŠ¤í…Œí”ˆ', 'JASMY': 'ì¬ìŠ¤ë¯¸',
      'FLOKI': 'í”Œë¡œí‚¤', 'BONK': 'ë´‰í¬', 'MEME': 'ë©”ë©”ì½”ì¸', 'WIF': 'ë„ê·¸ìœ„ë“œí–‡', 'POPCAT': 'íŒìº£'
    };

    // íˆ¬ìì ìˆ˜ë³„ ë§¤ë§¤ ê¸°ì¤€ ì„¤ì •
    function getTradingParams(score) {
      if (score >= 80) return { profitRate: 8, stopLoss: 3, tradable: true };
      if (score >= 70) return { profitRate: 6, stopLoss: 2.5, tradable: true };
      if (score >= 60) return { profitRate: 4, stopLoss: 2, tradable: true };
      if (score >= 50) return { profitRate: 3, stopLoss: 2, tradable: true };
      return { profitRate: 0, stopLoss: 0, tradable: false };
    }

    // ëª©í‘œê°€ ê³„ì‚°
    function calculateTargetPrice(currentPrice, score) {
      const params = getTradingParams(score);
      if (!params.tradable) return null;
      return Math.round(currentPrice * (1 + params.profitRate / 100));
    }

    // ì†ì ˆê°€ ê³„ì‚°
    function calculateStopLoss(currentPrice, score) {
      const params = getTradingParams(score);
      if (!params.tradable) return null;
      return Math.round(currentPrice * (1 - params.stopLoss / 100));
    }

    // íˆ¬ìì ìˆ˜ ê³„ì‚° í•¨ìˆ˜ë“¤ (ì´ì „ê³¼ ë™ì¼)
    function calculatePricePosition(data) {
      const current = parseFloat(data.closing_price);
      const min = parseFloat(data.min_price);
      const max = parseFloat(data.max_price);
      
      if (max === min) return 10;
      
      const position = (current - min) / (max - min);
      
      if (position >= 0.3 && position <= 0.7) return 15;
      if (position >= 0.2 && position <= 0.8) return 10;
      if (position >= 0.1 && position <= 0.9) return 5;
      return 0;
    }

    function calculateVolatility(data) {
      const min = parseFloat(data.min_price);
      const max = parseFloat(data.max_price);
      const opening = parseFloat(data.opening_price);
      
      if (opening === 0) return 0;
      
      const volatility = ((max - min) / opening) * 100;
      
      if (volatility >= 2 && volatility <= 8) return 10;
      if (volatility >= 1 && volatility <= 12) return 7;
      if (volatility >= 0.5 && volatility <= 15) return 4;
      return 0;
    }

    function calculateMomentum(data) {
      const rate24h = parseFloat(data.fluctate_rate_24H);
      const current = parseFloat(data.closing_price);
      const opening = parseFloat(data.opening_price);
      
      if (opening === 0) return 0;
      
      const dailyChange = ((current - opening) / opening) * 100;
      
      if (rate24h > 0 && rate24h <= 5 && dailyChange > 0) return 15;
      if (rate24h > 0 && rate24h <= 10) return 10;
      if (rate24h > -2 && rate24h <= 1) return 7;
      if (rate24h > -5 && rate24h <= -2) return 3;
      return 0;
    }

    function calculateVolumeHealth(data) {
      const volume = parseFloat(data.units_traded);
      const value = parseFloat(data.acc_trade_value);
      
      if (volume === 0 || value === 0) return 0;
      
      const avgPrice = value / volume;
      const currentPrice = parseFloat(data.closing_price);
      
      if (currentPrice === 0) return 0;
      
      const priceDeviation = Math.abs(currentPrice - avgPrice) / currentPrice;
      
      if (priceDeviation <= 0.01) return 15;
      if (priceDeviation <= 0.03) return 10;
      if (priceDeviation <= 0.05) return 5;
      return 0;
    }

    function calculateVolumeGrowth(data) {
      const volume = parseFloat(data.units_traded);
      const volume24h = parseFloat(data.units_traded_24H);
      
      if (volume === 0) return 0;
      
      if (volume24h > volume * 1.2) return 10;
      if (volume24h > volume * 1.1) return 7;
      if (volume24h > volume * 1.05) return 4;
      return 0;
    }

    function calculateStability(data) {
      const current = parseFloat(data.closing_price);
      const prev = parseFloat(data.prev_closing_price);
      
      if (prev === 0) return 0;
      
      const change = Math.abs((current - prev) / prev) * 100;
      
      if (change <= 3) return 10;
      if (change <= 7) return 6;
      if (change <= 15) return 2;
      return 0;
    }

    function calculateSupportLevel(data) {
      const current = parseFloat(data.closing_price);
      const min = parseFloat(data.min_price);
      const max = parseFloat(data.max_price);
      
      if (max === min) return 5;
      
      const distanceFromMin = (current - min) / (max - min);
      
      if (distanceFromMin >= 0.1 && distanceFromMin <= 0.3) return 10;
      if (distanceFromMin >= 0.05 && distanceFromMin <= 0.4) return 7;
      if (distanceFromMin >= 0.4 && distanceFromMin <= 0.6) return 4;
      return 0;
    }

    function calculateMarketPosition(allCoins, currentCoin) {
      const values = allCoins.map(coin => parseFloat(coin.acc_trade_value));
      values.sort((a, b) => b - a);
      
      const currentValue = parseFloat(currentCoin.acc_trade_value);
      const rank = values.indexOf(currentValue) + 1;
      const percentile = (values.length - rank) / values.length;
      
      if (percentile >= 0.9) return 15;
      if (percentile >= 0.7) return 12;
      if (percentile >= 0.5) return 8;
      if (percentile >= 0.3) return 4;
      return 0;
    }

    function calculateInvestmentScore(coinData, allCoinsData) {
      const pricePosition = calculatePricePosition(coinData);
      const volatility = calculateVolatility(coinData);
      const momentum = calculateMomentum(coinData);
      const volumeHealth = calculateVolumeHealth(coinData);
      const volumeGrowth = calculateVolumeGrowth(coinData);
      const stability = calculateStability(coinData);
      const supportLevel = calculateSupportLevel(coinData);
      const marketPosition = calculateMarketPosition(allCoinsData, coinData);
      
      const totalScore = pricePosition + volatility + momentum + volumeHealth + 
                        volumeGrowth + stability + supportLevel + marketPosition;
      
      return {
        totalScore,
        grade: getGrade(totalScore),
        recommendation: getRecommendation(totalScore),
        breakdown: {
          technical: pricePosition + volatility + momentum,
          volume: volumeHealth + volumeGrowth,
          risk: stability + supportLevel,
          market: marketPosition
        }
      };
    }

    function getGrade(score) {
      if (score >= 80) return 'A+';
      if (score >= 70) return 'A';
      if (score >= 60) return 'B+';
      if (score >= 50) return 'B';
      if (score >= 40) return 'C';
      return 'D';
    }

    function getRecommendation(score) {
      if (score >= 75) return 'ê°•ë ¥ ë§¤ìˆ˜';
      if (score >= 65) return 'ë§¤ìˆ˜';
      if (score >= 55) return 'ë³´ìœ ';
      if (score >= 45) return 'ê´€ë§';
      return 'ë§¤ë„ ê³ ë ¤';
    }

    // í† ìŠ¤íŠ¸ ë©”ì‹œì§€ í•¨ìˆ˜
    function showToast(message) {
      const existingToast = document.querySelector('.toast');
      if (existingToast) {
        existingToast.remove();
      }
      
      const toast = document.createElement('div');
      toast.className = 'toast';
      toast.textContent = message;
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.remove();
      }, 3000);
    }

    // ê´€ì‹¬ ì½”ì¸ í† ê¸€ í•¨ìˆ˜
    function toggleFavorite(symbol) {
      const index = favoriteCoins.indexOf(symbol);
      const wasRemoved = index > -1;
      
      if (wasRemoved) {
        favoriteCoins.splice(index, 1);
      } else {
        favoriteCoins.push(symbol);
      }
      localStorage.setItem('favoriteCoins', JSON.stringify(favoriteCoins));
      
      gridApi.refreshCells({
        force: true,
        columns: ['symbol']
      });
      
      gridApi.redrawRows();
      
      if (currentFilter === 'favorites') {
        applyFilter();
      }
      
      const coinName = getCoinName(symbol);
      const message = wasRemoved 
        ? `${coinName}(${symbol})ì´ ê´€ì‹¬ ì½”ì¸ì—ì„œ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.`
        : `${coinName}(${symbol})ì´ ê´€ì‹¬ ì½”ì¸ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.`;
      showToast(message);
    }

    // í•„í„° í† ê¸€ í•¨ìˆ˜
    function toggleFilter(filterType) {
      currentFilter = filterType;
      
      document.getElementById('allCoinsBtn').classList.toggle('active', filterType === 'all');
      document.getElementById('favoritesBtn').classList.toggle('active', filterType === 'favorites');
      document.getElementById('recommendedBtn').classList.toggle('active', filterType === 'recommended');
      
      applyFilter();
    }

    // í•„í„° ì ìš© í•¨ìˆ˜
    function applyFilter() {
      let filteredData = allCryptoData;
      
      if (currentFilter === 'favorites') {
        filteredData = allCryptoData.filter(coin => favoriteCoins.includes(coin.symbol));
      } else if (currentFilter === 'recommended') {
        filteredData = [...allCryptoData]
          .sort((a, b) => (b.investmentScore || 0) - (a.investmentScore || 0))
          .slice(0, 10);
      }
      
      gridApi.setGridOption('rowData', filteredData);
      updateCoinCount(filteredData.length);
      
      setTimeout(() => {
        gridApi.sizeColumnsToFit();
      }, 100);
    }

    // ì½”ì¸ ê°œìˆ˜ ì—…ë°ì´íŠ¸
    function updateCoinCount(count) {
      const totalCount = allCryptoData.length;
      const favoriteCount = favoriteCoins.length;
      const recommendedCount = 10;
      
      let countText = '';
      if (currentFilter === 'all') {
        countText = `ì „ì²´ ${totalCount}ê°œ ì½”ì¸ (ê´€ì‹¬ ì½”ì¸ ${favoriteCount}ê°œ)`;
      } else if (currentFilter === 'favorites') {
        countText = `ê´€ì‹¬ ì½”ì¸ ${count}ê°œ / ì „ì²´ ${totalCount}ê°œ`;
      } else if (currentFilter === 'recommended') {
        countText = `ì¶”ì²œ ì½”ì¸ ${count}ê°œ (íˆ¬ìì ìˆ˜ ìƒìœ„ ${recommendedCount}ê°œ)`;
      }
      
      document.getElementById('coinCount').textContent = countText;
    }

    // ì½”ì¸ëª… ê°€ì ¸ì˜¤ê¸° í•¨ìˆ˜
    const getCoinName = (symbol) => {
      return coinNames[symbol] || symbol;
    };

    // í¬ë§·íŒ… í•¨ìˆ˜ë“¤
    const formatPrice = (value) => {
      if (!value || value === '0') return '0';
      return parseFloat(value).toLocaleString('ko-KR') + ' ì›';
    };

    const formatVolume = (value) => {
      if (!value || value === '0') return '0';
      const num = parseFloat(value);
      if (num >= 1000000) return (num/1000000).toFixed(2) + 'M';
      if (num >= 1000) return (num/1000).toFixed(2) + 'K';
      return num.toFixed(4);
    };

    const formatRate = (value) => {
      if (!value || value === '0') return '0.00%';
      const rate = parseFloat(value);
      return (rate > 0 ? '+' : '') + rate.toFixed(2) + '%';
    };

    // ì‹¬ë³¼ ì…€ ë Œë”ëŸ¬
    const symbolCellRenderer = (params) => {
      const symbol = params.value;
      const coinName = getCoinName(symbol);
      const isFavorite = favoriteCoins.includes(symbol);
      
      const starIcon = isFavorite ? 'â˜…' : 'â˜†';
      const starClass = isFavorite ? 'active' : 'inactive';
      
      return `
        <div class="symbol-cell">
          <span class="favorite-star ${starClass}" 
                onclick="toggleFavorite('${symbol}')"
                title="${isFavorite ? 'ê´€ì‹¬ ì½”ì¸ì—ì„œ ì œê±°' : 'ê´€ì‹¬ ì½”ì¸ì— ì¶”ê°€'}"
                data-symbol="${symbol}">
            ${starIcon}
          </span>
          <div class="symbol-info">
            <div style="font-weight: bold; font-size: 14px;">${symbol}</div>
            <div class="coin-name">${coinName}</div>
          </div>
        </div>
      `;
    };

    // íˆ¬ìì ìˆ˜ ì…€ ë Œë”ëŸ¬
    const scoreCellRenderer = (params) => {
      const score = params.value || 0;
      const grade = params.data.grade || 'D';
      const gradeClass = `grade-${grade.replace('+', '-plus')}`;
      
      return `
        <div class="score-cell ${gradeClass}">
          <div style="text-align: center;">
            <div style="font-size: 16px;">${score}</div>
            <div style="font-size: 12px;">${grade}</div>
          </div>
        </div>
      `;
    };

    // ëª©í‘œê°€ ì…€ ë Œë”ëŸ¬
    const targetPriceCellRenderer = (params) => {
      const currentPrice = parseFloat(params.data.closing_price);
      const score = params.data.investmentScore || 0;
      const targetPrice = calculateTargetPrice(currentPrice, score);
      
      if (!targetPrice) {
        return '<div class="no-trade">ë§¤ìˆ˜ ì œì™¸</div>';
      }
      
      const params_trading = getTradingParams(score);
      return `
        <div class="target-price">
          <div style="font-size: 14px; font-weight: bold;">${targetPrice.toLocaleString('ko-KR')}ì›</div>
          <div style="font-size: 11px; color: #666;">(+${params_trading.profitRate}%)</div>
        </div>
      `;
    };

    // ì†ì ˆê°€ ì…€ ë Œë”ëŸ¬
    const stopLossCellRenderer = (params) => {
      const currentPrice = parseFloat(params.data.closing_price);
      const score = params.data.investmentScore || 0;
      const stopLoss = calculateStopLoss(currentPrice, score);
      
      if (!stopLoss) {
        return '<div class="no-trade">-</div>';
      }
      
      const params_trading = getTradingParams(score);
      return `
        <div class="stop-loss">
          <div style="font-size: 14px; font-weight: bold;">${stopLoss.toLocaleString('ko-KR')}ì›</div>
          <div style="font-size: 11px; color: #666;">(-${params_trading.stopLoss}%)</div>
        </div>
      `;
    };

    // AG Grid ì˜µì…˜
    const gridOptions = {
      columnDefs: [
        { 
          field: 'symbol', 
          headerName: 'ì•”í˜¸í™”í', 
          width: 160, 
          pinned: 'left',
          cellRenderer: symbolCellRenderer,
          cellStyle: { padding: '10px' }
        },
        { 
          field: 'investmentScore', 
          headerName: 'íˆ¬ìì ìˆ˜', 
          width: 90, 
          cellRenderer: scoreCellRenderer,
          sort: 'desc'
        },
        { 
          field: 'closing_price', 
          headerName: 'í˜„ì¬ê°€', 
          width: 130, 
          valueFormatter: params => formatPrice(params.value), 
          cellStyle: { fontWeight: 'bold', color: '#007bff', textAlign: 'right', paddingRight: '10px' }
        },
        { 
          field: 'targetPrice', 
          headerName: 'ëª©í‘œê°€', 
          width: 130, 
          cellRenderer: targetPriceCellRenderer,
          cellStyle: { textAlign: 'center', padding: '5px' }
        },
        { 
          field: 'stopLoss', 
          headerName: 'ì†ì ˆê°€', 
          width: 130, 
          cellRenderer: stopLossCellRenderer,
          cellStyle: { textAlign: 'center', padding: '5px' }
        },
        { 
          field: 'fluctate_rate_24H', 
          headerName: '24H ë³€ë™ë¥ ', 
          width: 110, 
          valueFormatter: params => formatRate(params.value),
          cellStyle: params => ({
            color: parseFloat(params.value) > 0 ? '#dc3545' : parseFloat(params.value) < 0 ? '#007bff' : '#333',
            fontWeight: 'bold',
            textAlign: 'right',
            paddingRight: '10px'
          })
        },
        { 
          field: 'recommendation', 
          headerName: 'ì¶”ì²œ', 
          width: 90, 
          cellStyle: params => {
            const rec = params.value;
            if (rec === 'ê°•ë ¥ ë§¤ìˆ˜') return { color: '#dc3545', fontWeight: 'bold', fontSize: '12px' };
            if (rec === 'ë§¤ìˆ˜') return { color: '#fd7e14', fontWeight: 'bold', fontSize: '12px' };
            if (rec === 'ë³´ìœ ') return { color: '#28a745', fontWeight: 'bold', fontSize: '12px' };
            if (rec === 'ê´€ë§') return { color: '#6c757d', fontSize: '12px' };
            return { color: '#007bff', fontSize: '12px' };
          }
        },
        { 
          field: 'opening_price', 
          headerName: 'ì‹œê°€', 
          width: 120, 
          valueFormatter: params => formatPrice(params.value),
          cellStyle: { textAlign: 'right', paddingRight: '10px', fontSize: '12px' }
        },
        { 
          field: 'min_price', 
          headerName: 'ìµœì €ê°€', 
          width: 120, 
          valueFormatter: params => formatPrice(params.value), 
          cellStyle: { color: '#dc3545', textAlign: 'right', paddingRight: '10px', fontSize: '12px' }
        },
        { 
          field: 'max_price', 
          headerName: 'ìµœê³ ê°€', 
          width: 120, 
          valueFormatter: params => formatPrice(params.value), 
          cellStyle: { color: '#28a745', textAlign: 'right', paddingRight: '10px', fontSize: '12px' }
        },
        { 
          field: 'units_traded', 
          headerName: 'ê±°ë˜ëŸ‰', 
          width: 100, 
          valueFormatter: params => formatVolume(params.value),
          cellStyle: { textAlign: 'right', paddingRight: '10px', fontSize: '12px' }
        },
        { 
          field: 'acc_trade_value', 
          headerName: 'ê±°ë˜ëŒ€ê¸ˆ', 
          width: 130, 
          valueFormatter: params => formatPrice(params.value),
          cellStyle: { textAlign: 'right', paddingRight: '10px', fontSize: '12px' }
        }
      ],
      defaultColDef: {
        sortable: true,
        filter: true,
        resizable: true,
        minWidth: 80,
        suppressSizeToFit: false
      },
      rowData: [],
      rowHeight: 60,
      getRowClass: (params) => {
        const classes = [];
        if (favoriteCoins.includes(params.data.symbol)) {
          classes.push('favorite-row');
        }
        if (currentFilter === 'recommended') {
          classes.push('recommended-row');
        }
        return classes.join(' ');
      },
      onGridReady: function(params) {
        gridApi = params.api;
        loadCryptoData();
        params.api.sizeColumnsToFit();
      },
      onGridSizeChanged: function(params) {
        params.api.sizeColumnsToFit();
      }
    };

    // ë°ì´í„° ë¡œë“œ í•¨ìˆ˜
    async function loadCryptoData() {
      const loadingDiv = document.getElementById('loading');
      loadingDiv.style.display = 'block';

      try {
        const response = await fetch('https://api.bithumb.com/public/ticker/ALL_KRW');
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.status !== '0000') {
          throw new Error('API ì‘ë‹µ ì˜¤ë¥˜: ' + data.message);
        }

        // ë°ì´í„° ë³€í™˜ ë° íˆ¬ìì ìˆ˜ ê³„ì‚°
        const rawData = Object.keys(data.data)
          .filter(symbol => symbol !== 'date')
          .map(symbol => ({
            symbol,
            coinName: getCoinName(symbol),
            ...data.data[symbol]
          }));

        // ê° ì½”ì¸ì— ëŒ€í•´ íˆ¬ìì ìˆ˜ ê³„ì‚°
        allCryptoData = rawData.map(coin => {
          const scoreResult = calculateInvestmentScore(coin, rawData);
          const currentPrice = parseFloat(coin.closing_price);
          
          return {
            ...coin,
            investmentScore: scoreResult.totalScore,
            grade: scoreResult.grade,
            recommendation: scoreResult.recommendation,
            targetPrice: calculateTargetPrice(currentPrice, scoreResult.totalScore),
            stopLoss: calculateStopLoss(currentPrice, scoreResult.totalScore)
          };
        });

        // íˆ¬ìì ìˆ˜ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
        allCryptoData.sort((a, b) => (b.investmentScore || 0) - (a.investmentScore || 0));

        applyFilter();
        
        console.log(`${allCryptoData.length}ê°œì˜ ì•”í˜¸í™”í ë°ì´í„°ê°€ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.`);
        updateDateTime();

      } catch (error) {
        console.error('ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
        showToast('ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        allCryptoData = [];
        applyFilter();
      } finally {
        loadingDiv.style.display = 'none';
      }
    }

    // í˜ì´ì§€ ë¡œë“œ ì‹œ AG Grid ì´ˆê¸°í™”
    document.addEventListener('DOMContentLoaded', function() {
      const gridDiv = document.getElementById('myGrid');
      agGrid.createGrid(gridDiv, gridOptions);
      
      document.getElementById('allCoinsBtn').classList.add('active');
    });
  </script>
</body>
</html>
